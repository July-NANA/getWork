# Floyd 判圈法

## 判断是否存在环路：

如果有限状态机、迭代函数或者链表存在环，那么一定存在一个起点可以到达某个环的某处(这个起点也可以在某个环上)。
初始状态下，假设已知某个起点节点为节点 S。现设两个指针 t 和 h，将它们均指向 S。接着，同时让 t 和 h 往前推进，但是二者的速度不同：t 每前进 1 步，h 前进 2 步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当 h 无法前进，即到达某个没有后继的节点时，就可以确定从 S 出发不会遇到环。反之当 t 与 h 再次相遇时，就可以确定从 S 出发一定会进入某个环，设其为环 C。如果确定了存在某个环，就可以求此环的起点与长度。

## 求解环路的长度：

上述算法刚判断出存在环 C 时，显然 t 和 h 位于同一节点，设其为节点 M。显然，仅需令 h 不动，而 t 不断推进，最终又会返回节点 M，统计这一次 t 推进的步数，显然这就是环 C 的长度。

## 求解环路的起点：

为了求出环 C 的起点，只要令 h 仍均位于节点 M，而令 t 返回起点节点 S，此时 h 与 t 之间距为环 C 长度的整数倍。随后，同时让 t 和 h 往前推进，且保持二者的速度相同：t 每前进 1 步，h 前进 1 步。持续该过程直至 t 与 h 再一次相遇，设此次相遇时位于同一节点 P，则节点 P 即为从节点 S 出发所到达的环 C 的第一个节点，即环 C 的一个起点。

## 对于环路起点算法的解释：

![解释.png](https://images2017.cnblogs.com/blog/885804/201708/885804-20170813223929242-1014504085.png "解释.png")

假设出发起点到环起点的距离为 m，已经确定有环，环的周长为 n，（第一次）相遇点距离环的起点的距离是 k。那么当两者相遇时，慢指针（t）移动的总距离 i = m + a _ n + k，快指针（h）的移动距离为 2i，2i = m + b _ n + k。其中，a 和 b 分别为 t 和 h 在第一次相遇时转过的圈数。让两者相减（快减慢），那么有 i = (b - a) \* n。即 i 是圈长度的倍数。
将一个指针移到出发起点 S，另一个指针仍呆在相遇节点 M 处两者同时移动，每次移动一步。当第一个指针前进了 m，即到达环起点时，另一个指针距离链表起点为 i + m。考虑到 i 为圈长度的倍数，可以理解为指针从链表起点出发，走到环起点，然后绕环转了几圈，所以第二个指针也必然在环的起点。即两者相遇点就是环的起点。

## 算法复杂度：

**时间复杂度**：注意到当指针 t 到达环 C 的一个起点节点 P 时(此时指针 h 显然在环 C 上)，之后指针 t 最多仅可能走 1 圈。若设节点 S 到 P 距离为 m，环 C 的长度为 n，则时间复杂度为 _O(m+n)_，是线性时间的算法。

**空间复杂度**：仅需要创立指针 t、指针 h，保存环长 n、环的一个起点 P。空间复杂度为*O(1)*，是常数空间的算法。

---

## ++和--的小技巧

> a++和++a 都是将 a 加 1，但是 a++返回值为 a，而++a 返回值为 a+1。如果只是希望增加 a 的值，而不需要返回值，则推荐使用++a，其运行速度会略快一些。
